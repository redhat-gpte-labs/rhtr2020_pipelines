:markup-in-source: verbatim,attributes,quotes
// URL needs to be defined as a variable because of `~` characters
:search_tasks_url: %web_console_url%/search/ns/pipeline-%guid%?kind=tekton.dev~v1beta1~Task

// Title comes from the workshop.yaml
// == OpenShift Pipeline

OpenShift Pipelines is a cloud-native, continuous integration and delivery (CI/CD) solution for building pipelines using https://tekton.dev/[Tekton]. Tekton is a flexible, Kubernetes-native, open-source CI/CD framework that enables automating deployments across multiple platforms (Kubernetes, serverless, VMs, etc) by abstracting away the underlying details.

== Understanding OpenShift Pipelines

Tekton defines a number of https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/[Kubernetes custom resources] as building blocks in order to standardize pipeline concepts and provide a terminology that is consistent across CI/CD solutions. 

The custom resources needed to define a pipeline are listed below:

* `Task`: a reusable, loosely coupled number of steps that perform a specific task (e.g. building a container image)
* `Pipeline`: the definition of the pipeline and the `Tasks` that it should perform
* `TaskRun`: the execution and result of running an instance of task
* `PipelineRun`: the execution and result of running an instance of pipeline, which includes a number of `TaskRuns`

image::https://raw.githubusercontent.com/openshift/pipelines-tutorial/master/docs/images/tekton-architecture.svg[Tekton Architecture]

In short, in order to create a pipeline, one does the following:

* Create custom or install https://github.com/tektoncd/catalog[existing] reusable `Tasks`
* Create a `Pipeline` and `PipelineResources` to define your application's delivery pipeline
* Create a `PersistentVolumeClaim` to provide the volume/filesystem for pipeline execution or provide a `VolumeClaimTemplate` which creates a `PersistentVolumeClaim`
* Create a `PipelineRun` to instantiate and invoke the pipeline

For further details on pipeline concepts, refer to the https://github.com/tektoncd/pipeline/tree/master/docs#learn-more[Tekton documentation] which provides an excellent guide for understanding various parameters and attributes available for defining pipelines.

OpenShift Pipelines are already installed in this cluster using the OpenShift Pipeline Operator.

== Convert the Jenkins pipeline into a Tekton pipeline

In this chapter we will convert the Groovy Jenkins pipeline that you executed in the previous chapter, into a Kubernetes-native YAML Tekton pipeline.

In order to achieve that, we will refactor all the steps from our original Pipeline into a new list of steps that better fit our new format.

image::images/jenkins_to_tekton_diagram.png[Jenkins to Tekton]

Let's use our Pipeline project *pipeline-%guid%* :

[source,bash,subs="{markup-in-source}",role=execute]
----
oc project pipeline-%guid%
----

=== Stages to Tasks

All Jenkins *Stages* will be converted into Tekton *Tasks* or *ClusterTasks*. A ClusterTask is a Tekton Task available for the whole cluster, and OpenShift Pipelines installs a number of them that are useful for many common use cases.

You can verify the list of available reusable ClusterTasks:

[source,bash,subs="{markup-in-source}",role=execute]
----
oc get clustertasks
----

For this exercise, we need two of them:

* *git-clone*: downloads the source code from Git Repositories, we will use it for this purpose with our private Git Repository from Gitea
* *maven*: performs Maven builds with target Maven goals, we will use it to run our builds and tests with Maven

All the other *Stages* will be converted with some custom *Tasks* we are going to define now:

* *s2i-java-11-binary-namespace*: a Task to build a container image from the artifact generated by a previous Maven ClusterTask, and then push it to a target namespace. For our purpose we need to push it to a _dev_ and a _prod_ project like before.
* *promote-to-prod*: a Task to tag our _dev_ image to _prod_ thus promoting it to the _prod_ project 
* *deploy-to-project*: a Task to deploy an existing container image to a target project. We will use it to deploy the app to our _dev_ and _prod_ environments

Let's create the tasks:

[source,bash,subs="{markup-in-source}",role=execute]
----
oc create -f https://raw.githubusercontent.com/redhat-gpte-labs/rhtr2020_pipelines/master/workshop/content/tekton/tasks/s2i-java-11-binary-ns.yaml -n pipeline-%guid%
----

[source,bash,subs="{markup-in-source}",role=execute]
----
oc create -f https://raw.githubusercontent.com/redhat-gpte-labs/rhtr2020_pipelines/master/workshop/content/tekton/tasks/promote-to-project.yaml -n pipeline-%guid%
----

[source,bash,subs="{markup-in-source}",role=execute]
----
oc create -f https://raw.githubusercontent.com/redhat-gpte-labs/rhtr2020_pipelines/master/workshop/content/tekton/tasks/deploy-to-project.yaml -n pipeline-%guid%
----

Now let's review the 3 tasks we just created:

[source,bash,subs="{markup-in-source}",role=execute]
----
oc get tasks -n pipeline-%guid%
----

We should see something similar:

.Sample Output
[source,options="nowrap",subs="{markup-in-source}"]
----
NAME                           AGE
deploy-to-project              2s
promote-to-prod                5s
s2i-java-11-binary-namespace   7s
----

Let's examine these tasks. You can do this either from the link:{search_tasks_url}[Web Console] (this link will only work if you are already logged into the Web Console) or via the command line:

[source,bash,subs="{markup-in-source}",role=execute]
----
oc get task s2i-java-11-binary-namespace -o yaml -n pipeline-%guid%
----

[source,bash,subs="{markup-in-source}",role=execute]
----
oc get task promote-to-prod -o yaml -n pipeline-%guid%
----

[source,bash,subs="{markup-in-source}",role=execute]
----
oc get task deploy-to-project -o yaml -n pipeline-%guid%
----

You can also examine the the *ClusterTasks*:

[source,bash,subs="{markup-in-source}",role=execute]
----
oc get clustertasks git-clone -o yaml -n pipeline-%guid%
----

[source,bash,subs="{markup-in-source}",role=execute]
----
oc get clustertasks maven -o yaml -n pipeline-%guid%
----

Tekton *Workspaces* allow you to specify one or more volumes that each Task in a Pipeline can use during execution. In our case, we need persistency between Tasks which are executed in different containers, so let's create some storage for our `Workspace` that we will call `app-source`:

[source,bash,subs="{markup-in-source}",role=execute]
----
oc create -f https://raw.githubusercontent.com/redhat-gpte-labs/rhtr2020_pipelines/master/workshop/content/tekton/pvc/workspace-pvc.yaml -n pipeline-%guid%
----

Now we have all the components that we can connect to create our Tekton Pipeline.

Let's review our Pipeline YAML:

[source,yaml,subs="{markup-in-source}",role=copypaste]
----
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: petclinic-pipeline
spec:
  params:
  - default: petclinic
    description: The application deployment name
    name: APP_NAME
    type: string
  - default: >-
      %gitea_url%
    description: The application git repository url
    name: APP_GIT_URL
    type: string
  - default: main
    description: The application git repository revision
    name: APP_GIT_REVISION
    type: string
  - default: 'petclinic:latest'
    description: The application image stream
    name: APP_IMAGE_STREAM
    type: string
  - default: petclinic-%guid%-dev
    name: DEV_NAMESPACE
    type: string
  - default: petclinic-%guid%-prod
    name: PROD_NAMESPACE
    type: string
  - default: http://nexus.nexus.svc:8081/repository/maven-all-public/
    name: MAVEN_MIRROR_URL
    type: string
  tasks:
  - name: git-clone
    params:
    - name: url
      value: $(params.APP_GIT_URL)
    - name: revision
      value: $(params.APP_GIT_REVISION)
    - name: deleteExisting
      value: 'true'
    taskRef:
      kind: ClusterTask
      name: git-clone
    workspaces:
    - name: output
      workspace: app-source

  - name: build
    params:
    - name: GOALS
      value:
      - -DskipTests
      - clean
      - package
    - name: MAVEN_MIRROR_URL
      value: $(params.MAVEN_MIRROR_URL)
    runAfter:
    - git-clone
    taskRef:
      kind: ClusterTask
      name: maven
    workspaces:
    - name: source
      workspace: app-source
    - name: maven-settings
      workspace: maven-settings

  - name: run-test
    params:
    - name: GOALS
      value:
      - test
    - name: MAVEN_MIRROR_URL
      value: $(params.MAVEN_MIRROR_URL)
    runAfter:
    - build
    taskRef:
      kind: ClusterTask
      name: maven
    workspaces:
    - name: source
      workspace: app-source
    - name: maven-settings
      workspace: maven-settings

  - name: build-image
    params:
    - name: TLSVERIFY
      value: 'false'
    - name: OUTPUT_IMAGE_STREAM
      value: $(params.APP_IMAGE_STREAM)
    - name: NAMESPACE
      value: $(params.DEV_NAMESPACE)
    runAfter:
    - run-test
    taskRef:
      kind: Task
      name: s2i-java-11-binary-namespace
    workspaces:
    - name: source
      workspace: app-source
  - name: deploy-to-dev
    params:
    - name: DEPLOYMENT
      value: $(params.APP_NAME)
    - name: IMAGE_STREAM
      value: $(params.APP_IMAGE_STREAM)
    - name: NAMESPACE
      value: $(params.DEV_NAMESPACE)
    runAfter:
    - build-image
    taskRef:
      kind: Task
      name: deploy-to-project
  
  - name: promote-to-prod
    params:
    - name: IMAGE_STREAM
      value: $(params.APP_IMAGE_STREAM)
    - name: DEPLOYMENT
      value: $(params.APP_NAME)
    - name: DEV_NAMESPACE
      value: $(params.DEV_NAMESPACE)
    - name: PROD_NAMESPACE
      value: $(params.PROD_NAMESPACE)
    runAfter:
    - deploy-to-dev
    taskRef:
      kind: Task
      name: promote-to-prod

  - name: deploy-to-prod
    params:
    - name: DEPLOYMENT
      value: $(params.APP_NAME)
    - name: IMAGE_STREAM
      value: '$(params.APP_NAME):prod'
    - name: NAMESPACE
      value: $(params.PROD_NAMESPACE)
    runAfter:
    - promote-to-prod
    taskRef:
      kind: Task
      name: deploy-to-project

  workspaces:
  - name: app-source
  - name: maven-settings
----

If you observe the code, Tekton pipelines accept some parameters - just like Jenkins pipelines - then define all required steps as a sequence of tasks to run. Those steps can be executed sequentially or in parallel, and they can share some storage defined as `Workspace`.

NOTE: One big difference between Jenkins and Tekton pipelines is the agent/executor. In Jenkins it's just one pod, scheduled by the Kubernetes plugin, executing all the steps. In Tekton, being a native extension of Kubernetes, there are many pods involved in the setup/execution. Each task, within the same Pipeline, is executed by a different pod - and each *step* in a task is executed in its own container. That's why we need a shared volume to let the `git-clone` task share data with the `maven` and subsequent tasks.

Now you can create the Pipeline inside the pipeline-%guid% project. You can do either from %web_console_url%[Web Console] pasting the above YAML content (left-side menu *Add+* -> *YAML*), or directly from the terminal:

[source,bash,subs="{markup-in-source}",role=execute]
----
cat <<'EOF' | oc apply -n pipeline-%guid% -f -
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: petclinic-pipeline
spec:
  params:
  - default: petclinic
    description: The application deployment name
    name: APP_NAME
    type: string
  - default: >-
      %gitea_url%
    description: The application git repository url
    name: APP_GIT_URL
    type: string
  - default: main
    description: The application git repository revision
    name: APP_GIT_REVISION
    type: string
  - default: 'petclinic:latest'
    description: The application image stream
    name: APP_IMAGE_STREAM
    type: string
  - default: petclinic-%guid%-dev
    name: DEV_NAMESPACE
    type: string
  - default: petclinic-%guid%-prod
    name: PROD_NAMESPACE
    type: string
  - default: http://nexus.nexus.svc:8081/repository/maven-all-public/
    name: MAVEN_MIRROR_URL
    type: string
  tasks:
  - name: git-clone
    params:
    - name: url
      value: $(params.APP_GIT_URL)
    - name: revision
      value: $(params.APP_GIT_REVISION)
    - name: deleteExisting
      value: 'true'
    taskRef:
      kind: ClusterTask
      name: git-clone
    workspaces:
    - name: output
      workspace: app-source

  - name: build
    params:
    - name: GOALS
      value:
      - -DskipTests
      - clean
      - package
    - name: MAVEN_MIRROR_URL
      value: $(params.MAVEN_MIRROR_URL)
    runAfter:
    - git-clone
    taskRef:
      kind: ClusterTask
      name: maven
    workspaces:
    - name: source
      workspace: app-source
    - name: maven-settings
      workspace: maven-settings

  - name: run-test
    params:
    - name: GOALS
      value:
      - test
    - name: MAVEN_MIRROR_URL
      value: $(params.MAVEN_MIRROR_URL)
    runAfter:
    - build
    taskRef:
      kind: ClusterTask
      name: maven
    workspaces:
    - name: source
      workspace: app-source
    - name: maven-settings
      workspace: maven-settings

  - name: build-image
    params:
    - name: TLSVERIFY
      value: 'false'
    - name: OUTPUT_IMAGE_STREAM
      value: $(params.APP_IMAGE_STREAM)
    - name: NAMESPACE
      value: $(params.DEV_NAMESPACE)
    runAfter:
    - run-test
    taskRef:
      kind: Task
      name: s2i-java-11-binary-namespace
    workspaces:
    - name: source
      workspace: app-source
  - name: deploy-to-dev
    params:
    - name: DEPLOYMENT
      value: $(params.APP_NAME)
    - name: IMAGE_STREAM
      value: $(params.APP_IMAGE_STREAM)
    - name: NAMESPACE
      value: $(params.DEV_NAMESPACE)
    runAfter:
    - build-image
    taskRef:
      kind: Task
      name: deploy-to-project
  
  - name: promote-to-prod
    params:
    - name: IMAGE_STREAM
      value: $(params.APP_IMAGE_STREAM)
    - name: DEPLOYMENT
      value: $(params.APP_NAME)
    - name: DEV_NAMESPACE
      value: $(params.DEV_NAMESPACE)
    - name: PROD_NAMESPACE
      value: $(params.PROD_NAMESPACE)
    runAfter:
    - deploy-to-dev
    taskRef:
      kind: Task
      name: promote-to-prod

  - name: deploy-to-prod
    params:
    - name: DEPLOYMENT
      value: $(params.APP_NAME)
    - name: IMAGE_STREAM
      value: '$(params.APP_NAME):prod'
    - name: NAMESPACE
      value: $(params.PROD_NAMESPACE)
    runAfter:
    - promote-to-prod
    taskRef:
      kind: Task
      name: deploy-to-project

  workspaces:
  - name: app-source
  - name: maven-settings
EOF
----

You can now review it also from %web_console_url%[Web Console], toggle *Developer Perspective*, select your project *pipeline-%guid%*, go to left-side menu, click *Pipelines* and you should see a new pipeline named *petclinic-pipeline*.

image::images/pipeline_overview.png[Pipeline Overview]

Verify it also from command line:

[source,bash,subs="{markup-in-source}",role=execute]
----
oc get pipeline -n pipeline-%guid%
----

=== tkn: The Tekton CLI 

Tekton has its own CLI for managing pipelines. This allows the developer to use the pipelines abstractions rather than having to deal with pods and containers.

[source,bash,subs="{markup-in-source}",role=execute]
----
tkn version
----

Check our pipeline:

[source,bash,subs="{markup-in-source}",role=execute]
----
tkn pipeline ls -n pipeline-%guid%
----

You should see an output like this:

.Sample Output
[source,texinfo]
----
NAME                 AGE              LAST RUN   STARTED   DURATION   STATUS
petclinic-pipeline   58 seconds ago   ---        ---       ---        ---
----
